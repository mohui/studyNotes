# redis事务
> 1. redis事务本质: 一组命令的集合, 一个事务中所有命令都会被序列化,在事务执行过程中,会按照顺序执行
> 2. 一次性 顺序性 排他性 执行一些列的命令

## redis的事务
- 开启事务(multi)
- 命令入队()
- 执行事务(exec)

### 事务示例
#### `mylti`: 开启事务
#### `exec`: 执行事务
#### `discard`: 取消事务
- 执行事务
```bash
multi # 开启事务

set k1 v1 # 命令入队
set k2 v2
get k2 # 没有结果
set k3 v3
exec # 执行事务
```
- 取消事务
```bash
set k12 v12
set k13 v13
discard # 放弃事务
get k13 # 报错, 因为事务取消了,所以k12,k13没有设置

```
#### redis单条命令式保存原子性的, 但是事务不保证原子性
#### redis事务没有隔离级别的概念
> 所有的命令在事务中, 并没有直接被执行, 只有发起执行命令的时候才会执行`exec`

#### 编译型异常
> 编译型异常(代码有问题, 命令有错), 事务中所有的命令都不会被执行

#### 运行时异常
> 运行时异常(1/0), 如果事务队列中存在语法性,那么执行命令的时候,其他命令式可以正常执行的,错误命令抛出异常
- 例如执行了A,B,C三条命令. 其中B错误,但是命令A,C依然执行成功,只有B会报错,影响不到A,C

## 监控 (watch)

### 悲观锁
- 很悲观, 认为什么时候都会出问题, 无论做什么都会加锁
### 乐观锁 
- 很乐观, 认为什么时候都不会出问题, 所以不会加锁,更新数据的时候去判断一下,在此期间是否有人修改过这个数据
> 1. 获取version
> 2. 更新的时候比较version
#### `watch`: 监控 `watch keyName` 
#### `unwatch`: 解锁 `unwatch`
```bash
set money 100 # 设置一个初始金额
set out 0 # 设置一个初始消费金额
watch money # 监视 `money`对象
multi # 开启事务, 如果事务正常结束, 数据期间没有发生变动,这个时候就正常执行成功
decrby money 20 # 减去20元
incrby out 20 # 消费金额加20元
exec # 成功
```
- 测试多线程修改值, 使用watch可以当做redis的乐观锁操作
```bash
 watch money # 监视 `money`对象
multi # 开启事务, 
decrby money 10 # 减去20元
incrby out 10 # 消费金额加20元
# 这个时候先不执行, 在另外一个线程中修改money的值, 比如另一个把money值修改为了1000
exec # 另一个线程修改以后再执行, 执行失败
unwatch # 如果发现事务执行失败,先解锁
watch money # 获取最新值, 再次监视, select version
multi #开启事务
decrby money 1 #减去1元
incrby money 1 # 增加1元
exec # 执行,成功 比对监视的值是否发生了变化,如果没有变化,执行成功. 如果有变化就执行失败,再次重复动作
```

```bash
set money 1000 # 这是另一个线程, 修改money的值
```