# MySQL 事务具有四个特性
> 原子性、一致性、隔离性、持久性，这四个特性简称 ACID 特性

- 隔离性： 锁机制实现
- 原子性，一致性，持久性：由事务的`redo`日志和`undo`日志来保证
> - redo log称为`重做日志`，提供在写入操作，恢复提交事务修改的页操作，用来保证事务的`持久性`
> - undo log称为`回滚日志`，回滚行记录到某个特定版本，用来保证事务的`原子性`和`一致性`
## 原子性（Atomicity ）
- 一个事务是一个不可再分割的整体，要么全部成功，要么全部失败

> 事务在数据库中就是一个基本的工作单位，事务中包含的逻辑操作（SQL 语句），
> 只有两种情况：成功和失败 。
> 事务的原子性其实指的就是这个逻辑操作过程具有原子性，不会出现有的逻辑操作成功，
> 有的逻辑操作失败这种情况

## 一致性（Consistency ）
- 一个事务可以让数据从一种一致状态切换到另一种一致性状态

> 举例说明：张三给李四转账 100 元，那么张三的余额应减少 100 元，
> 李四的余额应增加 100 元，张三的余额减少和李四的余额增加这是两个逻辑操作具有一致性

## 隔离性（Isolution ）
- 一个事务不受其他事务的影响，并且多个事务彼此隔离

> 一个事务内部的操作及使用的数据，对并发的其他事务是隔离的，
> 并发执行的各个事务之间不会互相干扰

## 持久性（Durability ）
- 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚

> 一个事务被提交后，在数据库中的改变就是永久的，
> 即使系统崩溃重新启动数据库数据也不会发生改变

# 隔离级别
> 1. 隔离级别是用于控制并发事务之间的相互影响程度的设置。MySQL 支持四种隔离级别，
> 2. 脏写 > 脏读 > 不可重复度 > 幻读

## 查询隔离级别
```sql
-- 5.7.2版本之前查询隔离级别SQL
show variables LIKE 'ts_isolation';
-- 5.7.2版本之后查询隔离级别SQL
show variables LIKE 'transaction_isolation';
    
-- 查询隔离级别(不分版本)
select @@transaction_isolation
```

## 读未提交（Read Uncommitted）
> 最低的隔离级别。事务之间没有隔离，一个事务可以读取另一个事务尚未提交的数据。
> 这可能导致脏读（Dirty Read），即读取到未提交的数据。
- 举例
> 1. 有A （100元），B（0元）两个人，A开启事务，A给B转了一百块钱，没有commit，
> 2. 这个时候B发现A给他转了一百块钱，B开启事务，把钱转回给A,因为A没有commit，B的页面会一直转圈等待
> 3. A不想转给B了，A执行了rollback,这时候A余额加一百，B余额减去一百
> 4. B因为A`rollback`成功，B的等待开始执行，B再次减去一百，A加一百
> 5. 最后的结果是A加了两百（A的余额是200），B减去了两百（B的余额是-100）

## 读已提交（Read Committed）
> 保证一个事务只能读取到已经提交的数据，避免了脏读。
> 但是在读取过程中，其他事务可能已经提交了新的数据，
> 可能会导致不可重复读（Non-Repeatable Read）。

## 可重复读（Repeatable Read）
> 保证在一个事务中多次读取同一数据时，其值不会发生变化。
> 其他事务可以插入新的数据，但是不能修改已有的数据。
> 但是在这个级别下，幻读（Phantom Read）问题可能出现，
> 即一个事务在同一条件下读取到不同的数据行。

## 串行化（Serializable）
> 最高的隔离级别。事务完全隔离，保证并发操作之间不会出现任何问题。
> 在这个级别下，所有的并发操作都会顺序执行，性能较差，但能够保证数据的完整性和一致性。


| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读可能性 |
|------|-------|----------|-------|--------|
| 读未提交 | YES   | YES      | YES   | NO     |
| 读已提交 | NO    | YES      | YES   | NO     |
| 可重复读 | NO    | NO       | YES   | NO     |
| 串行化  | NO    | NO       | NO    | YES    |

# 事务的状态
#### 活动的(active)
> 事务对应的数据库操作正在执行过程中时, 我们就说该事务处在`活动的`状态

#### 部分提交的(partially committed)
> 当十五中的最后一个操作完成,但由于操作都在内存中执行\
> 所造成的影响并`没有刷新到磁盘`时, 我们就说改事务处在`部分提交的`状态

#### 失败的(failed)
> 当事务处在`活动的`或者`部分提交的`状态,可能遇到某些错误(数据库自身,操作系统,或者直接断电等错误)而无法继续执行, 
> 或者人为的停止当前事务的执行, 我们就说改事务处在失败的`状态

#### 中止的(aborted)
> 如果事务执行了一部分而变为`失败的`状态, 那么就需要把已经修改的事务中的操作还原到事务执行前 的状态  
> 换句话说就是要撤销失败事务对当前数据库造成的影响,  
> 我们把这个撤销的过程称之为回滚, 当回滚操作执行完毕时,也就是数据库恢复到执行事务之前的状态, 我们就说该事务处在`中止的状态`

#### 提交的(committed)
> 当一个处在部分提交的事务将修改过的数据都同步到磁盘上之后,我们就可以说该事务处在了`提交的状态`