# 表锁
> 该锁会锁定整张表，它是`mysql`中最基本的锁策略，并`不依赖于存储引擎`，
> （不管你是mysql的什么存储引擎，对于表锁的策略都是一样的），并且表锁是`开销最小`的策略（因为粒度比较大）。
> 由于表级锁一次会将整个表锁定，所以可以很好的`避免死锁`问题。
> 当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致`并发率大打折扣`
## 表级别的S锁，X锁
>> 在对某个表执行`SELECT`,`INSERT`,`DELETE`,`UPDATE`语句时，
> `innodb`存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的，
> 在对某个表执行一些诸如`ALTER TABLE`,`DROP TABLE`这类的`DDL`语句时，
> 其他事务对这个表并发执行诸如`SELECT`,`INSERT`,`DELETE`,`UPDATE`的语句会发生阻塞，
> 同理，某个事务中对某个表执行`SELECT`,`INSERT`,`DELETE`,`UPDATE`语句时，
> 其他会话中对这个表执行`DDL`语句也会发生阻塞。
> 这个过程其实是通过在`server层`使用一种称之为`元数据锁`（Metadata Locks,简称MDL）结构来实现的
> 
>> 一般情况下，不会使用`innodb`存储引擎提供的表级别的`S锁`和`X锁`，只会在一些特殊情况下，比如`崩溃恢复`
> 过程中用到，比如，在系统变量`autocommit = 0`,`innodb_table_locks = 1`时，手动获取`innodb存储引擎`
> 提供的`表t`的`S锁`或者`X锁`，可以这么写
> - `LOCK TABLES t READ`: `innodb存储引擎`会对`表t`加表级别的`S锁`
> - `LOCK TABLES t WRITE`: `innodb存储引擎`会对`表t`加表级别的`X锁`
>
>> 不过尽量避免在使用`innodb存储引擎`的表上使用`lock table`这样的手动锁表语句。
> 它们并不会提供什么额外的保护，只是会降低并发能力而已，`Innodb`的厉害之处还是实现了更细粒度的`行锁`，
> 关于`innoDb`表级别的`S锁`和`X锁`了解就可

```sql
-- 查看锁
show open 表名 where in_use > 0;
-- 例如表名为 mylock;
show open mylock where in_use > 0;
-- 释放锁
unlock tables;
```

### 总结
> `MyISAM`在执行查询语句（select）前,会给涉及的所有表加`读锁`，
> 在执行增删改操作前， 会给涉及的表加`写锁`，
> `Innodb存储引擎`是不会为这个表添加表级别的`读锁`或者`写锁`的

> MySQL的表锁有两种模式（以`myisam`表进行操作的演示）
> - 表共享读锁（Table Read Lock）
> - 表独占写锁（Table Write Lock）

| 锁类型    | 自己可读 | 自己可写 | 自己可操作其他表 | 他人可写 | 他人可写 |
|--------|------|------|----------|------|------|
| 读锁(S锁) | 是    | 否    | 否        | 是    | 否，等  |
| 写锁(X锁) | 是    | 是    | 否        | 否，等  | 否，等  |

## 意向锁

### 意向锁分为两种
- `意向共享锁`：事务有意向对表中的某些行加`共享锁`（S锁）
```sql
-- 事务要获取某些行的 S锁，必须先获得表的`IS锁`
SELECT column FROM table ... Lock in share mode;
```
- `意向排他锁`：事务有意向对表中的某些行家`排它锁`（X锁）
```sql
-- 事务要获取某些行的 X锁，必须先获得表的`IX锁`
SELECT column FROM table ... FOR UPDATE;
```
> 意向锁是由存储引擎自己维护的，用户无法手动操作`意向锁`，在为数据行加`共享锁/排他锁`之前，
> `innoDb`会先获取该数据行`所在数据表的对应意向锁`

## 结论
> 1. `InnoDB`支持`多粒度锁`，特定场景下，行级锁可以与表级锁共存
> 2. 意向锁之间互不排斥，但除了`IS`与`S`兼容外，`意向锁`会与`共享锁`和`排他锁`互斥
> 3. `IX`,`IS`是表级锁，不会和行级的`X锁`和`S锁`发生冲突，只会和表级的`X锁`和`S锁`发生冲突
> 4. 意向锁在保证并发性的前提下，实现了`行锁和表锁共存`，且`满足事务隔离性`的要求